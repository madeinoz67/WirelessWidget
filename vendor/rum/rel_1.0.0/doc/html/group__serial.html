<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>RUM: Serial Port</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Serial Port</h1><hr><a name="_details"></a><h2>Detailed Description</h2>
This file implements a stand-alone serial port interface for the AVR. 
<p>
Input and output buffering are implemented. The port is set for 38.4KBPS, no parity, 8 bits, and 1 stop bit.<p>
To use this serial port, call <a class="el" href="group__serial.html#g364b552759a6ed3c410d2ebb770975b7" title="USART initialization.">serial_init()</a> once. Then you can send data over the serial port using <a class="el" href="group__serial.html#g10ca3a011a28e64adeb559fe71373c82" title="This function will place a character into the serial buffer.">serial_putchar()</a> and <a class="el" href="group__serial.html#g332d255b8b89981594cf9f3dde7dfc58" title="Sends an ASCIIZ string to the serial port.">serial_puts()</a>.<p>
To receive serial data, you can call <a class="el" href="group__serial.html#g4b0fa10a931750ad29deb068cfd1e54b" title="Returns a character from the serial port.">serial_getchar()</a> and <a class="el" href="group__serial.html#gc0ee16939b4816b2ca3bb093c6891739" title="Captures a string from serial port.">serial_gets()</a>, but beware that these are blocking functions, and will simply wait for an incoming character, preventing any other activity on the AVR. To prevent this, you can either poll the serial buffer with the <a class="el" href="group__serial.html#g46a01c0d9f12d9deaf905f76463175ac" title="Check to see if any characters are waiting in the serial input buffer.">serial_ischar()</a> function, or you can set an RX interrupt callback function to be called every time a character is received. Set this callback function as a parameter to the <a class="el" href="group__serial.html#g364b552759a6ed3c410d2ebb770975b7" title="USART initialization.">serial_init()</a> function. 
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Baud rate definitions</h2></td></tr>
<tr><td colspan="2">See the appropriate AVR datasheet for details.<p>
These macros assume that the AVR clock speed is 8MHz. <br><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2e187b6db95fce15c2ca648fd820f4e0"></a><!-- doxytag: member="serial::BAUD_RATE_38400" ref="g2e187b6db95fce15c2ca648fd820f4e0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g2e187b6db95fce15c2ca648fd820f4e0">BAUD_RATE_38400</a>&nbsp;&nbsp;&nbsp;(12)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register setting for 38.4 KBaud. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7ac7dae9d640cde3f5996d014c1a6690"></a><!-- doxytag: member="serial::BAUD_RATE_9600" ref="g7ac7dae9d640cde3f5996d014c1a6690" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g7ac7dae9d640cde3f5996d014c1a6690">BAUD_RATE_9600</a>&nbsp;&nbsp;&nbsp;(51)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Register setting for 9600 Baud. <br></td></tr>
<tr><td colspan="2"><br><h2>These are GUI to Radio Binary commands.</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gc75793e83cf12d3fb678977ed72f5fc2"></a><!-- doxytag: member="serial::NULL_CMD" ref="gc75793e83cf12d3fb678977ed72f5fc2" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>NULL_CMD</b>&nbsp;&nbsp;&nbsp;(0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g0f6d3c1d47a3e2121f6ff1658c6bf409"></a><!-- doxytag: member="serial::CMD_TEMP" ref="g0f6d3c1d47a3e2121f6ff1658c6bf409" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CMD_TEMP</b>&nbsp;&nbsp;&nbsp;(0x80)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5136a632807dc8816d1a4443f526568d"></a><!-- doxytag: member="serial::CMD_PING_COORD" ref="g5136a632807dc8816d1a4443f526568d" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CMD_PING_COORD</b>&nbsp;&nbsp;&nbsp;(0x81)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge81ba7bb7019a415d125064495264304"></a><!-- doxytag: member="serial::CMD_PING_GOOGLE" ref="ge81ba7bb7019a415d125064495264304" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CMD_PING_GOOGLE</b>&nbsp;&nbsp;&nbsp;(0x82)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g860c4dd07aed48fcfee4f704dccf409a"></a><!-- doxytag: member="serial::CMD_PING_SERVER" ref="g860c4dd07aed48fcfee4f704dccf409a" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CMD_PING_SERVER</b>&nbsp;&nbsp;&nbsp;(0x83)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ge8b6e20fa0580c44f8e8935cf9375d53"></a><!-- doxytag: member="serial::CMD_PING_NODE" ref="ge8b6e20fa0580c44f8e8935cf9375d53" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CMD_PING_NODE</b>&nbsp;&nbsp;&nbsp;(0x84)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g449f63dd94f20ce83204072b61da94ac"></a><!-- doxytag: member="serial::CMD_LED" ref="g449f63dd94f20ce83204072b61da94ac" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>CMD_LED</b>&nbsp;&nbsp;&nbsp;(0x85)</td></tr>

<tr><td colspan="2"><br><h2>These are the Radio to GUI binary commands.</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga74d5be89df50bb2b1fe00903f4b0224"></a><!-- doxytag: member="serial::REPORT_PING" ref="ga74d5be89df50bb2b1fe00903f4b0224" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REPORT_PING</b>&nbsp;&nbsp;&nbsp;(0xC0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g525c291c45d30955e4149c6a1a19e161"></a><!-- doxytag: member="serial::REPORT_PING_BEEP" ref="g525c291c45d30955e4149c6a1a19e161" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REPORT_PING_BEEP</b>&nbsp;&nbsp;&nbsp;(0xC1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g2015769e8146a7e44628264c779fe1f0"></a><!-- doxytag: member="serial::REPORT_TEXT_MSG" ref="g2015769e8146a7e44628264c779fe1f0" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REPORT_TEXT_MSG</b>&nbsp;&nbsp;&nbsp;(0xC2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g16edfa772db757aadb72c964e85de83f"></a><!-- doxytag: member="serial::REPORT_ASSOCIATED" ref="g16edfa772db757aadb72c964e85de83f" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REPORT_ASSOCIATED</b>&nbsp;&nbsp;&nbsp;(0xC3)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g361a45141a690608e89fc062bcec31f1"></a><!-- doxytag: member="serial::REPORT_LED" ref="g361a45141a690608e89fc062bcec31f1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><b>REPORT_LED</b>&nbsp;&nbsp;&nbsp;(0xC4)</td></tr>

<tr><td colspan="2"><br><h2>UART setup macros</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gd00c352475642d171a07cea2ce7d54b6">USART_STOP</a>()&nbsp;&nbsp;&nbsp;UCSR(USART,B) = 0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Configure the UART for use.  <a href="#gd00c352475642d171a07cea2ce7d54b6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g972d9c126d1214a11589193043e6c780"></a><!-- doxytag: member="serial::USART_CHAR_READY" ref="g972d9c126d1214a11589193043e6c780" args="()" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g972d9c126d1214a11589193043e6c780">USART_CHAR_READY</a>()&nbsp;&nbsp;&nbsp;(!(UCSR(USART,B) &amp; (1&lt;&lt;UDRIE(USART))))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Is there a received character waiting in the UART? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g8776f390ac4d084dd487f948bdb25ba4"></a><!-- doxytag: member="serial::USART_DRE_WAIT" ref="g8776f390ac4d084dd487f948bdb25ba4" args="()" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g8776f390ac4d084dd487f948bdb25ba4">USART_DRE_WAIT</a>()&nbsp;&nbsp;&nbsp;(!(UCSR(USART,A) &amp; (1&lt;&lt;UDRE(USART))))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Wait for the Data Register to be empty. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga3a2a42d78b16184d7874b6b0f56da24"></a><!-- doxytag: member="serial::USART_REG" ref="ga3a2a42d78b16184d7874b6b0f56da24" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga3a2a42d78b16184d7874b6b0f56da24">USART_REG</a>&nbsp;&nbsp;&nbsp;(UDR(USART))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">UART data register. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ga34b484624d2b5532b7557da0bfdc787"></a><!-- doxytag: member="serial::USART_DRE_ENABLE" ref="ga34b484624d2b5532b7557da0bfdc787" args="()" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ga34b484624d2b5532b7557da0bfdc787">USART_DRE_ENABLE</a>()&nbsp;&nbsp;&nbsp;(UCSR(USART,B) |= (1&lt;&lt;UDRIE(USART)))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Eanble the data register empy interrupt. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g97625bfb1242f1084e5c51b5d72dd772"></a><!-- doxytag: member="serial::USART_DRE_DISABLE" ref="g97625bfb1242f1084e5c51b5d72dd772" args="()" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g97625bfb1242f1084e5c51b5d72dd772">USART_DRE_DISABLE</a>()&nbsp;&nbsp;&nbsp;((UCSR(USART,B) &amp;= ~(1&lt;&lt;UDRIE(USART))))</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disable the data register empy interrupt. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gdabf9d1045e689ae97d56140ba402377"></a><!-- doxytag: member="serial::USARTRXVECT" ref="gdabf9d1045e689ae97d56140ba402377" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gdabf9d1045e689ae97d56140ba402377">USARTRXVECT</a>&nbsp;&nbsp;&nbsp;RXVECT(USART)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">UART Rx vector. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g47ba29aa0513c89e68e45ebe9ce07280"></a><!-- doxytag: member="serial::USARTTXVECT" ref="g47ba29aa0513c89e68e45ebe9ce07280" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g47ba29aa0513c89e68e45ebe9ce07280">USARTTXVECT</a>&nbsp;&nbsp;&nbsp;UDREVECT(USART)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">UART Tx vector. <br></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gae3f0b4211ba45d265973d40ccbb5fd1">SERIAL</a>&nbsp;&nbsp;&nbsp;1</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Flag to enable the serial port.  <a href="#gae3f0b4211ba45d265973d40ccbb5fd1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g5988beb3a83b8a8814d7ff87c4704daf"></a><!-- doxytag: member="serial::SOF_CHAR" ref="g5988beb3a83b8a8814d7ff87c4704daf" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g5988beb3a83b8a8814d7ff87c4704daf">SOF_CHAR</a>&nbsp;&nbsp;&nbsp;(0x01)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Start-of-frame character. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="gb18403818d9f9ca598d4a5bb1980f0e1"></a><!-- doxytag: member="serial::EOF_CHAR" ref="gb18403818d9f9ca598d4a5bb1980f0e1" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gb18403818d9f9ca598d4a5bb1980f0e1">EOF_CHAR</a>&nbsp;&nbsp;&nbsp;(0x04)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">End-of-frame character. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g00e4cc9bfeecc68ee12ac25bde9bd897"></a><!-- doxytag: member="serial::TERM_CHAR" ref="g00e4cc9bfeecc68ee12ac25bde9bd897" args="" -->
#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g00e4cc9bfeecc68ee12ac25bde9bd897">TERM_CHAR</a>&nbsp;&nbsp;&nbsp;(0x14)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Control-T ASCII value for entering terminal mode. <br></td></tr>
<tr><td colspan="2"><br><h2>Typedefs</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">typedef void(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g90dd845f56c13d2485d228d40f19db70">t_rx_handler</a> )(u8 ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RX handler callback function definition.  <a href="#g90dd845f56c13d2485d228d40f19db70"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g364b552759a6ed3c410d2ebb770975b7">serial_init</a> (<a class="el" href="group__serial.html#g90dd845f56c13d2485d228d40f19db70">t_rx_handler</a> rxh)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USART initialization.  <a href="#g364b552759a6ed3c410d2ebb770975b7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g7ac25b1935d8030b7f657dd1989cc51b"></a><!-- doxytag: member="serial::serial_shutdown" ref="g7ac25b1935d8030b7f657dd1989cc51b" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g7ac25b1935d8030b7f657dd1989cc51b">serial_shutdown</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Turns off the serial port and RCB_BB transmitter chip. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g10ca3a011a28e64adeb559fe71373c82">serial_putchar</a> (char ch)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This function will place a character into the serial buffer.  <a href="#g10ca3a011a28e64adeb559fe71373c82"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g332d255b8b89981594cf9f3dde7dfc58">serial_puts</a> (char *str)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sends an ASCIIZ string to the serial port.  <a href="#g332d255b8b89981594cf9f3dde7dfc58"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g46a01c0d9f12d9deaf905f76463175ac">serial_ischar</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check to see if any characters are waiting in the serial input buffer.  <a href="#g46a01c0d9f12d9deaf905f76463175ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g11703a83027741f65da679b221bd314f">rx_buf_count</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check to see if serial transmit buffer can accept more chars.  <a href="#g11703a83027741f65da679b221bd314f"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">s8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g4b0fa10a931750ad29deb068cfd1e54b">serial_getchar</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns a character from the serial port.  <a href="#g4b0fa10a931750ad29deb068cfd1e54b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gc0ee16939b4816b2ca3bb093c6891739">serial_gets</a> (char *str, u8 len, u8 echo)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Captures a string from serial port.  <a href="#gc0ee16939b4816b2ca3bb093c6891739"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gb684f2b6a9a5986085cf874eec04c2d6">serial_toggle_pause</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Toggles the pause flag.  <a href="#gb684f2b6a9a5986085cf874eec04c2d6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">u8&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#gc4e9c77fea48d38fdffb2b9c3291ca8e">serial_rcv_frame</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This will receive a frame from the ATmega3290p and parse the incoming data.  <a href="#gc4e9c77fea48d38fdffb2b9c3291ca8e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#ge6ec1b0980c6041775c2a6dfac755b48">ISR</a> (USARTRXVECT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USART ISR RX function.  <a href="#ge6ec1b0980c6041775c2a6dfac755b48"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="g400acf7f0aa78186060a230f9318f0d2"></a><!-- doxytag: member="serial::ISR" ref="g400acf7f0aa78186060a230f9318f0d2" args="(USARTTXVECT)" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__serial.html#g400acf7f0aa78186060a230f9318f0d2">ISR</a> (USARTTXVECT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">USART ISR TX function. <br></td></tr>
</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="gae3f0b4211ba45d265973d40ccbb5fd1"></a><!-- doxytag: member="mac.h::SERIAL" ref="gae3f0b4211ba45d265973d40ccbb5fd1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SERIAL&nbsp;&nbsp;&nbsp;1          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Flag to enable the serial port. 
<p>
Set this to one to enable the port. 
<p>Definition at line <a class="el" href="mac_8h-source.html#l00177">177</a> of file <a class="el" href="mac_8h-source.html">mac.h</a>.</p>

<p>Referenced by <a class="el" href="rum__application_8c-source.html#l00555">appAssociateConfirm()</a>, <a class="el" href="rum__application_8c-source.html#l00210">appPingReq()</a>, <a class="el" href="rum__application_8c-source.html#l00234">appPingRsp()</a>, <a class="el" href="rum__application_8c-source.html#l00932">appTask()</a>, <a class="el" href="mac_8c-source.html#l00076">macInit()</a>, <a class="el" href="sleep_8c-source.html#l00073">nodeSleep()</a>, <a class="el" href="radio_8c-source.html#l00124">radioInit()</a>, <a class="el" href="sensors_8c-source.html#l00586">sensorCalProcess()</a>, <a class="el" href="serial_8c-source.html#l00413">serial_rcv_frame()</a>, and <a class="el" href="avr__sixlowpan__application_8c-source.html#l00161">sixlowpan_udp_usercall()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gd00c352475642d171a07cea2ce7d54b6"></a><!-- doxytag: member="serial.h::USART_STOP" ref="gd00c352475642d171a07cea2ce7d54b6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define USART_STOP          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;UCSR(USART,B) = 0</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configure the UART for use. 
<p>
Shutdown the UART module 
<p>Definition at line <a class="el" href="serial_8h-source.html#l00161">161</a> of file <a class="el" href="serial_8h-source.html">serial.h</a>.</p>

<p>Referenced by <a class="el" href="serial_8c-source.html#l00232">serial_shutdown()</a>.</p>

</div>
</div><p>
<hr><h2>Typedef Documentation</h2>
<a class="anchor" name="g90dd845f56c13d2485d228d40f19db70"></a><!-- doxytag: member="serial.h::t_rx_handler" ref="g90dd845f56c13d2485d228d40f19db70" args=")(u8 ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* <a class="el" href="group__serial.html#g90dd845f56c13d2485d228d40f19db70">t_rx_handler</a>)(u8 ch)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
RX handler callback function definition. 
<p>
Define a function like the one below to recieve each serial character, and pass this function name to the <a class="el" href="group__serial.html#g364b552759a6ed3c410d2ebb770975b7" title="USART initialization.">serial_init()</a> function.<p>
<div class="fragment"><pre class="fragment">   <span class="keywordtype">void</span> rxHandler(u8 ch)
   {
     <span class="comment">// Do something with ch, which is the received character.</span>
     <span class="comment">// Or, more likely, set a flag to go check for</span>
     <span class="comment">// received serial chars in the input buffer.</span>
   }
</pre></div><p>
Remember that this function is not meant to be used to process the serial input stream. It is called from an interrupt, so you must not call application code from the RX handler function. Use the <a class="el" href="group__serial.html#g46a01c0d9f12d9deaf905f76463175ac" title="Check to see if any characters are waiting in the serial input buffer.">serial_ischar()</a> and <a class="el" href="group__serial.html#g4b0fa10a931750ad29deb068cfd1e54b" title="Returns a character from the serial port.">serial_getchar()</a> functions to retrieve serial data. 
<p>Definition at line <a class="el" href="serial_8h-source.html#l00069">69</a> of file <a class="el" href="serial_8h-source.html">serial.h</a>.</p>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="ge6ec1b0980c6041775c2a6dfac755b48"></a><!-- doxytag: member="serial.c::ISR" ref="ge6ec1b0980c6041775c2a6dfac755b48" args="(USARTRXVECT)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ISR           </td>
          <td>(</td>
          <td class="paramtype">USARTRXVECT&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
USART ISR RX function. 
<p>
If an RX handler was passed to <a class="el" href="group__serial.html#g364b552759a6ed3c410d2ebb770975b7" title="USART initialization.">serial_init()</a>, then that handler will be called each time this ISR is called. 
<p>Definition at line <a class="el" href="serial_8c-source.html#l00499">499</a> of file <a class="el" href="serial_8c-source.html">serial.c</a>.</p>

<p>References <a class="el" href="serial_8h-source.html#l00167">USART_REG</a>.</p>

</div>
</div><p>
<a class="anchor" name="g11703a83027741f65da679b221bd314f"></a><!-- doxytag: member="serial.c::rx_buf_count" ref="g11703a83027741f65da679b221bd314f" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 rx_buf_count           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check to see if serial transmit buffer can accept more chars. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if we can take for chars, otherwise false. </dd></dl>

<p>Definition at line <a class="el" href="serial_8c-source.html#l00304">304</a> of file <a class="el" href="serial_8c-source.html">serial.c</a>.</p>

</div>
</div><p>
<a class="anchor" name="g4b0fa10a931750ad29deb068cfd1e54b"></a><!-- doxytag: member="serial.c::serial_getchar" ref="g4b0fa10a931750ad29deb068cfd1e54b" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s8 serial_getchar           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a character from the serial port. 
<p>
Will wait for input if necessary. To prevent blocking while waiting for serial input, check circ_buf_count() first.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Character from serial port. </dd></dl>

<p>Definition at line <a class="el" href="serial_8c-source.html#l00327">327</a> of file <a class="el" href="serial_8c-source.html">serial.c</a>.</p>

<p>Referenced by <a class="el" href="rum__application_8c-source.html#l00932">appTask()</a>, <a class="el" href="serial_8c-source.html#l00347">serial_gets()</a>, and <a class="el" href="serial_8c-source.html#l00413">serial_rcv_frame()</a>.</p>

</div>
</div><p>
<a class="anchor" name="gc0ee16939b4816b2ca3bb093c6891739"></a><!-- doxytag: member="serial.c::serial_gets" ref="gc0ee16939b4816b2ca3bb093c6891739" args="(char *str, u8 len, u8 echo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 serial_gets           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">u8&nbsp;</td>
          <td class="paramname"> <em>echo</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Captures a string from serial port. 
<p>
This function blocks until a carriage return character is received.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Pointer to asciiz string to store characters to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>len</em>&nbsp;</td><td>Maximum number of characters to get, including terminating zero. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>echo</em>&nbsp;</td><td>Specifies whether to echo each character received back to host.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Number of characters in string. </dd></dl>

<p>Definition at line <a class="el" href="serial_8c-source.html#l00347">347</a> of file <a class="el" href="serial_8c-source.html">serial.c</a>.</p>

<p>References <a class="el" href="serial_8c-source.html#l00327">serial_getchar()</a>, and <a class="el" href="serial_8c-source.html#l00245">serial_putchar()</a>.</p>

<p>Referenced by <a class="el" href="rum__application_8c-source.html#l00932">appTask()</a>, and <a class="el" href="sensors_8c-source.html#l00586">sensorCalProcess()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="group__serial_gc0ee16939b4816b2ca3bb093c6891739_cgraph.png" border="0" usemap="#group__serial_gc0ee16939b4816b2ca3bb093c6891739_cgraph_map" alt=""></center>
<map name="group__serial_gc0ee16939b4816b2ca3bb093c6891739_cgraph_map">
<area shape="rect" href="group__serial.html#g4b0fa10a931750ad29deb068cfd1e54b" title="Returns a character from the serial port." alt="" coords="140,5,241,32"><area shape="rect" href="group__serial.html#g10ca3a011a28e64adeb559fe71373c82" title="This function will place a character into the serial buffer." alt="" coords="140,56,241,83"></map>
</div>

</div>
</div><p>
<a class="anchor" name="g364b552759a6ed3c410d2ebb770975b7"></a><!-- doxytag: member="serial.c::serial_init" ref="g364b552759a6ed3c410d2ebb770975b7" args="(t_rx_handler rxh)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serial_init           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__serial.html#g90dd845f56c13d2485d228d40f19db70">t_rx_handler</a>&nbsp;</td>
          <td class="paramname"> <em>rxh</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
USART initialization. 
<p>
This function sets the USART initialization to the following: USART Baud rate: 38,400 USART Data bit: 8 USART Parity Mode: Diabled USART Stop bit: 1 USART Receiver: On USART Transmitter: On USART Mode: Asynchronous<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>rxh</em>&nbsp;</td><td>RX interrupt handler, a user-defined function that can optionally be called when a serial char is received. See <a class="el" href="group__serial.html#g90dd845f56c13d2485d228d40f19db70">t_rx_handler</a>. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="serial_8c-source.html#l00207">207</a> of file <a class="el" href="serial_8c-source.html">serial.c</a>.</p>

<p>References <a class="el" href="hal__avr_8h-source.html#l00684">INIT_RCB_BB</a>, <a class="el" href="hal__avr_8h-source.html#l00096">PLATFORM</a>, <a class="el" href="hal__avr_8h-source.html#l00067">RAVEN</a>, and <a class="el" href="hal__avr_8h-source.html#l00068">RAVENUSB</a>.</p>

<p>Referenced by <a class="el" href="sleep_8c-source.html#l00073">nodeSleep()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g46a01c0d9f12d9deaf905f76463175ac"></a><!-- doxytag: member="serial.c::serial_ischar" ref="g46a01c0d9f12d9deaf905f76463175ac" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 serial_ischar           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Check to see if any characters are waiting in the serial input buffer. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The number of characters waiting </dd></dl>

<p>Definition at line <a class="el" href="serial_8c-source.html#l00293">293</a> of file <a class="el" href="serial_8c-source.html">serial.c</a>.</p>

<p>Referenced by <a class="el" href="rum__application_8c-source.html#l00932">appTask()</a>, <a class="el" href="sensors_8c-source.html#l00586">sensorCalProcess()</a>, and <a class="el" href="serial_8c-source.html#l00413">serial_rcv_frame()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g10ca3a011a28e64adeb559fe71373c82"></a><!-- doxytag: member="serial.c::serial_putchar" ref="g10ca3a011a28e64adeb559fe71373c82" args="(char ch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serial_putchar           </td>
          <td>(</td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>ch</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function will place a character into the serial buffer. 
<p>
Will simply return if buffer is already full.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ch</em>&nbsp;</td><td>Character to be placed in the serial output buffer and then transmitted over the serial port. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="serial_8c-source.html#l00245">245</a> of file <a class="el" href="serial_8c-source.html">serial.c</a>.</p>

<p>References <a class="el" href="hal__avr_8h-source.html#l00096">PLATFORM</a>, <a class="el" href="hal__avr_8h-source.html#l00068">RAVENUSB</a>, <a class="el" href="serial_8h-source.html#l00163">USART_CHAR_READY</a>, <a class="el" href="serial_8h-source.html#l00169">USART_DRE_ENABLE</a>, <a class="el" href="serial_8h-source.html#l00165">USART_DRE_WAIT</a>, and <a class="el" href="serial_8h-source.html#l00167">USART_REG</a>.</p>

<p>Referenced by <a class="el" href="serial_8c-source.html#l00347">serial_gets()</a>, and <a class="el" href="serial_8c-source.html#l00278">serial_puts()</a>.</p>

</div>
</div><p>
<a class="anchor" name="g332d255b8b89981594cf9f3dde7dfc58"></a><!-- doxytag: member="serial.c::serial_puts" ref="g332d255b8b89981594cf9f3dde7dfc58" args="(char *str)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serial_puts           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>str</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends an ASCIIZ string to the serial port. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>str</em>&nbsp;</td><td>Pointer to ASCIIZ terminated string to send. </td></tr>
  </table>
</dl>

<p>Definition at line <a class="el" href="serial_8c-source.html#l00278">278</a> of file <a class="el" href="serial_8c-source.html">serial.c</a>.</p>

<p>References <a class="el" href="serial_8c-source.html#l00245">serial_putchar()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="group__serial_g332d255b8b89981594cf9f3dde7dfc58_cgraph.png" border="0" usemap="#group__serial_g332d255b8b89981594cf9f3dde7dfc58_cgraph_map" alt=""></center>
<map name="group__serial_g332d255b8b89981594cf9f3dde7dfc58_cgraph_map">
<area shape="rect" href="group__serial.html#g10ca3a011a28e64adeb559fe71373c82" title="This function will place a character into the serial buffer." alt="" coords="140,5,241,32"></map>
</div>

</div>
</div><p>
<a class="anchor" name="gc4e9c77fea48d38fdffb2b9c3291ca8e"></a><!-- doxytag: member="serial.c::serial_rcv_frame" ref="gc4e9c77fea48d38fdffb2b9c3291ca8e" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">u8 serial_rcv_frame           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This will receive a frame from the ATmega3290p and parse the incoming data. 
<p>
This function assembles a frame one byte at a time.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if frame has been received. </dd></dl>

<p>Definition at line <a class="el" href="serial_8c-source.html#l00413">413</a> of file <a class="el" href="serial_8c-source.html">serial.c</a>.</p>

<p>References <a class="el" href="serial_8c-source.html#l00093">EOF_CHAR</a>, <a class="el" href="hal__avr_8h-source.html#l00096">PLATFORM</a>, <a class="el" href="hal__avr_8h-source.html#l00067">RAVEN</a>, <a class="el" href="mac_8h-source.html#l00177">SERIAL</a>, <a class="el" href="serial_8c-source.html#l00327">serial_getchar()</a>, <a class="el" href="serial_8c-source.html#l00293">serial_ischar()</a>, and <a class="el" href="serial_8c-source.html#l00092">SOF_CHAR</a>.</p>

<p>Referenced by <a class="el" href="rum__application_8c-source.html#l00932">appTask()</a>.</p>

<p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dynsection">
<p><center><img src="group__serial_gc4e9c77fea48d38fdffb2b9c3291ca8e_cgraph.png" border="0" usemap="#group__serial_gc4e9c77fea48d38fdffb2b9c3291ca8e_cgraph_map" alt=""></center>
<map name="group__serial_gc4e9c77fea48d38fdffb2b9c3291ca8e_cgraph_map">
<area shape="rect" href="group__serial.html#g4b0fa10a931750ad29deb068cfd1e54b" title="Returns a character from the serial port." alt="" coords="169,5,271,32"><area shape="rect" href="group__serial.html#g46a01c0d9f12d9deaf905f76463175ac" title="Check to see if any characters are waiting in the serial input buffer." alt="" coords="173,56,267,83"></map>
</div>

</div>
</div><p>
<a class="anchor" name="gb684f2b6a9a5986085cf874eec04c2d6"></a><!-- doxytag: member="serial.c::serial_toggle_pause" ref="gb684f2b6a9a5986085cf874eec04c2d6" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void serial_toggle_pause           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Toggles the pause flag. 
<p>
When paused, any data sent to the serial send function is dropped. 
<p>Definition at line <a class="el" href="serial_8c-source.html#l00388">388</a> of file <a class="el" href="serial_8c-source.html">serial.c</a>.</p>

<p>Referenced by <a class="el" href="rum__application_8c-source.html#l00932">appTask()</a>.</p>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jun 8 18:38:56 2009 for RUM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
