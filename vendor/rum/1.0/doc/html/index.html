<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>RUM: RUM (Route-Under-MAC) network</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>RUM (Route-Under-MAC) network</h1>
<p>
<h3 align="center">1.0 </h3><h2><a class="anchor" name="more_info">
More Information Available</a></h2>
Atmel appnote <b>AVR2070</b> includes much of the info in this Doxygen-generated documentation, and also guides you through getting this software working on a variety of hardware platforms. The appnote is available on Atmel's website <a href="http://www.atmel.com/wireless.">http://www.atmel.com/wireless.</a> This document gives details about the inner workings of the firmware, while the AppNote is oriented toward helping a new user get the firmware running on real hardware.<h2><a class="anchor" name="intro">
Introduction</a></h2>
The RUM network is a simple, small, multi-hop, self-forming network. It has the following characteristics:<p>
<ul>
<li>Small object size. Current implementation (MAC with tiny app) is well under 8KB for an end node.</li></ul>
<p>
<ul>
<li>Coordinator is required. The coordinator is the only node that has any "smarts", and the routers and end-nodes are quite simple. This allows for cheap hardware for both routers and end-nodes.</li></ul>
<p>
<ul>
<li>Self-forming network. The nodes wake up and can find a network and associate to it.</li></ul>
<p>
<ul>
<li>Multi-hop routing is supported. There is no practical limit to the number of hops.</li></ul>
<p>
<ul>
<li>IPv6 Support allows nodes to communicate across the world seamlessly.</li></ul>
<p>
<ul>
<li>Open protocol. Free for use with Atmel hardware.</li></ul>
<h2><a class="anchor" name="api">
Application Programming Interface</a></h2>
An application talks to the MAC by using a few function calls in the MAC, and the MAC communicates events back to the application by calling pre-defined callback functions. The relevant MAC functions and the callback functions are declared in the header file <a class="el" href="system_8h-source.html">system.h</a>.<p>
All of the application-level RUM API callback functions exist in <a class="el" href="rum__application_8c-source.html">rum_application.c</a>. This file should be used as a basis for new applications. Particularly, the <a class="el" href="group__app.html#g85919e96b4d8f3aee13a5eb3a10dfd03" title="Callback function, called when the MAC receives an association confirm packet addressed...">appAssociateConfirm()</a> function is called when the node becomes associated to a network. Users should should use this function as a starting point for application-specific behavior.<p>
As shipped, the firmware will automatically initialize the network and create connections between nodes. A user application does not need to do anything to create the network. The three basic functions to be used by an application are:<p>
<ul>
<li><a class="el" href="group__app.html#g85919e96b4d8f3aee13a5eb3a10dfd03" title="Callback function, called when the MAC receives an association confirm packet addressed...">appAssociateConfirm()</a> to begin operating on the network.</li></ul>
<p>
<ul>
<li><a class="el" href="group__mac__data.html#g57df637c21a2060c49e6e19c09b38d30" title="The macsixlowpanDataRequest function is used to send a frame over the air to another...">macDataRequest()</a> to send data.</li></ul>
<p>
<ul>
<li><a class="el" href="group__app.html#g24a5a30fe61f32e1bd405f431bd46527" title="Callback function, called when the MAC receives a data packet for this node.">appDataIndication()</a> to process received data.</li></ul>
<p>
The functions listed below are the major parts of the MAC software, but are not intended to be used directly by the application.<h3><a class="anchor" name="coord_commands">
Coordinator commands</a></h3>
<ul>
<li><a class="el" href="group__mac__scan.html#g26cb107f1a13ba8b3ba4008d00eb6b54" title="This function is used by the coordinator to find a clear channel to use for the PAN...">macFindClearChannel()</a> is called on startup. The new coordinator node finds a clear channel by doing an energy scan and finding the quietest channel. Alternatively, a pre-defined channel can be set in <a class="el" href="group__mac__associate.html#g339b747fe4e5bb7e7f252ba56727e3f5">PAN_CHANNEL</a>.</li></ul>
<p>
<ul>
<li><a class="el" href="group__app.html#g8f71d0c0ed4dfe867f3cd0208a1299b6" title="Callback function, called when macFindClearChannel() completes.">appClearChanFound()</a> is called when the scan is complete. The coordinator chooses a channel and PAN ID by calling <a class="el" href="group__mac.html#gd9b6aa9e3aa0f562f49354f26bbf56ba" title="This function will cause a device to become a PAN Coordinator.">macStartCoord()</a>, and is then ready for operation.</li></ul>
<p>
<ul>
<li>When the coordinator receives a beacon request, it calls sendBeaconFrame(), which sends a beacon back to the requester.</li></ul>
<p>
<ul>
<li>When the coordinator receives an association request, it calls <a class="el" href="group__mac__associate.html#gb66e6617d404824a1be943d829ed0d8e" title="This function is called when an association request is received by this node (and...">macAssociationResponse()</a>, which stores the new node's information in the coordinator's network table, and issues an association response frame.</li></ul>
<h3><a class="anchor" name="router_commands">
Router and end node commands</a></h3>
On the router/end node side, several functions are called in sequence associate to the network. The timing of these calls are regulated by the MAC's <a class="el" href="group__timer__module.html">Timer module</a>, by making calls to <a class="el" href="group__timer__module.html#g0155e5192956b3cd498751d8652f7773" title="Sets a general purpose timer.">macSetAlarm()</a>.<p>
<ul>
<li><a class="el" href="group__mac.html#gaa0748a32ee5741afc6a5078d92158bb" title="Init the mac, which includes initializing the radio chip.">macInit()</a> is called to initialize the radio and the MAC.</li></ul>
<p>
<ul>
<li><a class="el" href="group__mac__scan.html#g9b962c94bc13ed89a2d2a8590ed487f4" title="Scan channels for coordinators.">macScan()</a> is then called to search for a network to join. This causes the node to send out beacon request nodes on every channel, and to record the beacons it gets back. The best node is chosen.</li></ul>
<p>
<ul>
<li><a class="el" href="group__app.html#g43fb16d48be1908e0a007eaccb6280c9" title="Callback function, called when the MAC has completed its channel scan.">appScanConfirm()</a> is called when the scan is complete. If the scan was successful, then appScanConfirm calls appAssociate, which in turn calls ...</li></ul>
<p>
<ul>
<li><a class="el" href="group__mac__associate.html#ge044ad02d7a264fe88176c4076809853" title="Associate this node with a network.">macAssociate()</a> - this sends an association request to the coordinator (sometimes via intermediate nodes), and processes an association response packet with ...</li></ul>
<p>
<ul>
<li><a class="el" href="group__app.html#g85919e96b4d8f3aee13a5eb3a10dfd03" title="Callback function, called when the MAC receives an association confirm packet addressed...">appAssociateConfirm()</a> is called when the node either associates successfully, or times out waiting to associate.</li></ul>
<p>
After the nodes have associated the macConfig.associated flag is set to true and , all nodes communicate using the same functions:<p>
<ul>
<li><a class="el" href="group__mac__data.html#g57df637c21a2060c49e6e19c09b38d30" title="The macsixlowpanDataRequest function is used to send a frame over the air to another...">macDataRequest()</a> is called by the sending node, or <a class="el" href="group__mac__data.html#g7e4c5d07ec7a2622dabbcf51b1fe4ba9" title="Send a ping packet (either request or response) to another node.">macPing()</a> is called to ping another node. The MAC calls back to either <a class="el" href="group__app.html#g165181964bf513258f8c195c36483774" title="Application callback function, called when the MAC receives an ACK packet from a...">appPacketSendSucceed()</a> or <a class="el" href="group__app.html#gaab9f419d476077682bd9e42b06aad39" title="Application callback function, called when the MAC fails to receive an ACK packet...">appPacketSendFailed()</a>.</li></ul>
<p>
<ul>
<li><a class="el" href="group__mac__data.html#gd3e85e09f6dbb0b41c432986a4a17fec" title="This function is called when the MAC receives a packet that is addressed to this...">macDataIndication()</a> is called by the MAC if a packet is received that is addressed to this node.</li></ul>
<p>
For more detailed examples of association and sending sensor data, see <a class="el" href="group__mac.html#mac_calls">MAC function calls</a> and <a class="el" href="group__sensors.html#sensorcalls">Sensor application function calls</a>.<p>
There are a few other useful functions that the MAC offers. These functions are useful for making a non-networking applications, such as a remote control unit.<p>
<ul>
<li><a class="el" href="group__mac__associate.html#ged6df4ec4a8b1f717d6591f7bc73627a" title="Determine if a given node is a child if this node.">macIsChild()</a> reports on whether a given node is a child of this node.</li></ul>
<p>
<ul>
<li><a class="el" href="group__mac.html#g62d975ef98590e2c23229df7b6d041c6" title="Set the radio&#39;s operating channel, and saves that channel to the MAC&#39;s global...">macSetOperatingChannel()</a> can be used to manually set the radio channel.</li></ul>
<p>
<ul>
<li><a class="el" href="group__radio.html#g2976f50bf538933d7eba0444494d6289" title="Returns the radio part number.">radioGetPartnum()</a> will query the Atmel radio chip and return the part number.</li></ul>
<p>
<ul>
<li><a class="el" href="group__radio.html#g8a4202486f04e061df72ec19973be447" title="Retrieves the saved RSSI (Received Signal Strength Indication) value.">radioGetSavedRssiValue()</a> returns the last measured received signal strength indication (RSSI) value for a received packet.</li></ul>
<p>
<ul>
<li><a class="el" href="group__radio.html#gb89f723b3d8357a3c254083b36bef539" title="Retrieves the saved LQI (Link Quality Indication) value.">radioGetSavedLqiValue()</a> returns the last measured link quality indication (LQI) value for a received packet.</li></ul>
<p>
<ul>
<li><a class="el" href="group__radio.html#g1c1b73c569365e457a1d9b9b773eadbb" title="This function will return the channel used by the radio transceiver.">radioGetOperatingChannel()</a></li></ul>
<p>
<ul>
<li><a class="el" href="group__radio.html#g0c689f664f8c670a4bc0d5c014bee03f" title="This function will read and return the output power level.">radioGetTxPowerLevel()</a> and <a class="el" href="group__radio.html#g304d72041bb3ee614ac9e5dd0f9cd2bc" title="This function will change the output power level.">radioSetTxPowerLevel()</a> set and read the output RF power levels</li></ul>
<p>
<ul>
<li><a class="el" href="group__radio.html#ge1c88b412735308dfc1901f114a8ca66" title="This function returns the current threshold volatge used by the battery monitor (BATMON_VTH)...">radioBatmonGetVoltageThreshold()</a>, <a class="el" href="group__radio.html#g09332abc57dc69b296b23e650324daf6" title="This function returns if high or low voltage range is used.">radioBatmonGetVoltageRange()</a>, <a class="el" href="group__radio.html#gfc0224268575b799b05e6163dae5456a" title="This function is used to configure the battery monitor module.">radioBatmonConfigure()</a>, and <a class="el" href="group__radio.html#g8029b4f59bd19747a3090cf56adfd912" title="This function returns the status of the Battery Monitor module.">radioBatmonGetStatus()</a> are used to work with the RF2xx on-board battery monitor function.</li></ul>
<p>
<ul>
<li><a class="el" href="group__radio.html#ge1c39dc3b5d283a37058861892222fda" title="This function returns the current clock setting for the CLKM pin.">radioGetClockSpeed()</a> and <a class="el" href="group__radio.html#g52391d34dfa78c4ad817e3f18b0de579" title="This function changes the prescaler on the CLKM pin.">radioSetClockSpeed()</a> allow the use of the RF2xx CLKM signal, which can be used to clock the CPU or provide an accurate timebase to calibrate any other oscillator.</li></ul>
<p>
<ul>
<li><a class="el" href="group__radio.html#g324b48dc10d81456ce6ddd909f1d5e83" title="This function will put the radio transceiver to sleep.">radioEnterSleepMode()</a> puts the radio chip to sleep and <a class="el" href="group__radio.html#g9b993ad338e639b917540d835079ce84" title="This function will take the radio transceiver from sleep mode and put it into the...">radioLeaveSleepMode()</a> wakes up the radio chip.</li></ul>
<p>
<ul>
<li><a class="el" href="group__radio.html#g73d762673c6af21f4fb6b6ba6c06cc63" title="This function will download a frame to the radio transceiver&#39;s transmit buffer...">radioSendData()</a> sends a "raw" packet over the radio. This is a lower-level function that RUM uses to send data to another node.</li></ul>
<p>
<ul>
<li><a class="el" href="group__radio.html#g301044554e9d047bf22935d01c615884" title="Returns a random number, composed of bits from the radio&#39;s random number generator...">radioRandom()</a> returns up to 8 bits of random data, created from the random radio noise on the RF2xx chip. The RF230 does not have a random number generator, so the radioRandom function only returns a random number from the rand() system function.</li></ul>
<p>
<ul>
<li><a class="el" href="group__sleep.html#g93b5cdc0c2f6e617c9e63fac53cc8271" title="Put the node to sleep.">nodeSleep()</a> Puts the entire node to sleep for a specified time.</li></ul>
<p>
Other MAC parameters reside in the <a class="el" href="group__mac.html#g495ae4288ec139138c9ca2b8de136245">macConfig</a> structure. While this structure is not meant to be used by the application directly, several useful parameters are available for reference:<p>
<ul>
<li><b>longAddr</b> - The long (MAC) address of this node</li><li><b>associated</b> - True if this node has been associated to a network</li><li><b>panId</b> - The PAN ID of this node</li><li><b>shortAddress</b> - the short address of this node</li><li><b>parentShortAddress</b> - the short address of this node's parent</li><li><b>currentChannel</b> - the current radio channel selected</li></ul>
<p>
The <a class="el" href="group__timer__module.html">Timer module</a> can be used by an application to execute functions after a non-blocking delay.<p>
The <a class="el" href="group__serial.html">Serial Port</a> module provides a serial port for the AVR targets.<h3><a class="anchor" name="ipv6_commands">
IPv6 Router and End-Node Commands</a></h3>
The router and end-node provide limited IPv6 support. The functions for IPv6 are tailored to perform the most likely actions an end-node would require, rather than supporting the entire IPv6 standard. This includes ping responses, ping requests, and UDP support. The easiest method of understanding is to study the <a class="el" href="group__avr6lowpan__example.html">AVR 6LoWPAN Example Application</a>.<p>
<ul>
<li><a class="el" href="group__avr6lowpan.html#g5587e78871f5562126152360689c466b" title="User callback when a UDP packet is received on 6LoWPAN.">sixlowpan_udp_usercall()</a> is called when an incoming UDP frame is received. The user can then process the data, and optionally send a response back to the source.</li></ul>
<p>
<ul>
<li><a class="el" href="group__avr6lowpan.html#g805964e13e701bdde2a4058f8a44ce50" title="Setup a UDP packet for off-link IP addresses.">sixlowpan_hc01_udp_setup_ipglobal()</a> Is used to set up an outgoing UDP frame to a global IP address. See the <a class="el" href="group__avr6lowpan__example.html">AVR 6LoWPAN Example Application</a> source code for an example.</li></ul>
<p>
<ul>
<li><a class="el" href="group__avr6lowpan.html#g95782dbcd4ab7838c617ba6f224a2d88" title="Setup an ICMPv6 Echo Request packet for off-link IP addresses.">sixlowpan_hc01_ping_setup_ipglobal()</a> Is used to set up an outgoing ping request to a global IP address. See the <a class="el" href="group__avr6lowpan__example.html">AVR 6LoWPAN Example Application</a> source code for an example.</li></ul>
<p>
<ul>
<li><a class="el" href="group__avr6lowpan.html#gc33c962f057d3ef7787483909b6426bd" title="User callback when an ICMP Echo Response is received.">sixlowpan_ping_usercall()</a> is called when an incoming echo response is received.</li></ul>
<h2><a class="anchor" name="comps">
Components</a></h2>
There are a few modules that make up this project. These are all compiled together into one object file, but some of these modules can be left out of the compilation based on <a class="el" href="index.html#compile_options">Compile-time options</a>.<p>
<ul>
<li><a class="el" href="group__app.html">Sample Application</a> provided as a basis for a simple user application.</li></ul>
<p>
<ul>
<li><a class="el" href="group__avr6lowpan.html">6LoWPAN implementation for AVR</a> 6LoWPAN Layer to provide IPv6 Connectivity</li></ul>
<p>
<ul>
<li><a class="el" href="group__mac.html">Route Under Mac (RUM)</a>. A subset of the MAC defined by IEEE 802.15.4. This includes multi-hop and self-forming functionality.</li></ul>
<p>
<ul>
<li><a class="el" href="group__radio.html">Radio interface</a> between the MAC layer to the Atmel AT86RF2xx radio chip.</li></ul>
<p>
<ul>
<li><a class="el" href="group__timer__module.html">Timer module</a> to support MAC events and any user-created events.</li></ul>
<p>
<ul>
<li><a class="el" href="group__serial.html">Serial Port</a> code to support debugging or a serial connection to another device. This code can be left out of the project to reduce object code size.</li></ul>
<p>
<ul>
<li><a class="el" href="group__sensors.html">Sensor Application</a> to demonstrate a simple data-collection network, including wireless calibration of sensors.</li></ul>
<h2><a class="anchor" name="esplanade">
How the components work together</a></h2>
The example application runs on "bare metal", that is, without any kind of operating system. In main(), there is a "forever" loop that continously calls the two program "threads", <a class="el" href="group__app.html#g0b12d03da74adb585dc8600038837f15" title="Sample application task loop function.">appTask()</a> and <a class="el" href="group__mac__event.html#g9b4bd3c99bd01a997dfbf36de2db14ae" title="This is the main loop task for the MAC.">macTask()</a>. These tasks process the events that occur in the background, such as the timer interrupt and the radio interrupt.<p>
The interrupt routines that handle radio and timer events post an event object into the event queue (see <a class="el" href="group__mac__event.html#g546b1497ed4c233b1bbfcc34c0b386be">mac_put_event()</a>). The <a class="el" href="group__mac__event.html#g9b4bd3c99bd01a997dfbf36de2db14ae" title="This is the main loop task for the MAC.">macTask()</a> function checks this queue and processes posted events, most of which were initiated by an interrupt service routine (ISR).<p>
The <a class="el" href="group__serial.html">Serial Port</a> runs by itself in a stand-alone way. The only interaction between the serial module and the rest of the program is through functions like <a class="el" href="group__serial.html#g4b0fa10a931750ad29deb068cfd1e54b" title="Returns a character from the serial port.">serial_getchar()</a> and <a class="el" href="group__serial.html#g10ca3a011a28e64adeb559fe71373c82" title="This function will place a character into the serial buffer.">serial_putchar()</a>. A serial queue is used for both sending and receiving characters over the serial port.<p>
The <a class="el" href="group__timer__module.html">Timer module</a> implements an easy-to-use interface to allow delayed processing of events. This module is available for use by the<p>
The <a class="el" href="group__radio.html">Radio interface</a> provides a device driver for the radio chip. This layer resides below the MAC layer, and the two layers talk directly to each other.<h2><a class="anchor" name="compiling">
Compiling</a></h2>
This package can be compiled on several host platforms, with many options for the target environment. The code is written for the GCC compiler (ver 4.3.0), which has been compiled as a cross compiler for AVR. See the avr-libc project <a href="http://www.nongnu.org/avr-libc/">http://www.nongnu.org/avr-libc/</a> for details.<h3><a class="anchor" name="hostwin">
Windows Host Platform</a></h3>
Compile and program the code into the target using Atmel's AVR Studio (available free at <a href="http://www.atmel.com">http://www.atmel.com</a>). You will also have to install WinAVR, which is the AVR GCC toolchain compiled for a Win32 host.<p>
There are AVR Studio project files supplied for the various builds. Load the project file and press the compile button. If you have a debugger connected to the target, you may load the code into the target and begin debugging.<p>
There are a number options listed in <a class="el" href="index.html#compile_options">Compile-time options</a>. To enable or disable an option, add it to the list of compiler options as shown below.<p>
<div align="center">
<img src="studio-options1.png" alt="studio-options1.png">
</div>
 <h3><a class="anchor" name="hostlin">
Linux Host Platform</a></h3>
This package includes a linux Makefile. To compile RUM on a linux platform, issue a command like<p>
<div class="fragment"><pre class="fragment">   make <a class="code" href="group__radio.html#g1fa4f1561216be34f745f32aaa38d943" title="Defines the platform for which we are building the firmware.">PLATFORM</a>=<a class="code" href="group__radio.html#gc82593c377f09ea46615d0d27b4ea63e" title="Radio control board, designed for use with RF230.">RCB230</a> <a class="code" href="group__app.html#gd72dbcf6d0153db1b8d8a58001feed83" title="The global debugging flag.">DEBUG</a>=0 TYPE=<a class="code" href="group__mac.html#g5794c1a5f0eedfe85aea59330c25848a" title="Router node.">ROUTER</a>
</pre></div><p>
This makefile accepts a number of parameters as shown above. The list of available compile-time parameters is in the next section.<h3><a class="anchor" name="compile_options">
Compile-time options</a></h3>
These options affect which features are included in a RUM build. These options are in the Makefile or can be added to the AVR Studio project file.<p>
<ul>
<li>TYPE can be END, ROUTER, or COORD. This directs which kind of node is being compiled. This parameter is required. The makefile sets the <a class="el" href="group__mac.html#g59569ff056c7f0f124222ca0013728d5">NODETYPE</a> macro.</li></ul>
<p>
<ul>
<li><a class="el" href="group__radio.html#g1fa4f1561216be34f745f32aaa38d943">PLATFORM</a> can be RCB230, RCB231, RCB212, RAVEN, RAVENUSB, or SPITFIRE. This sets the MCU flag and other parameters to compile the code for a specific platform. If this parameter is left out, the PLATFORM will be set to the default (COORD). Note that a platform defines how the CPU and radio chip are connected together. It does not specify which radio chip is being used, though it does specify the <a class="el" href="group__radio.html#gb57e5c97e5d788f048284f1175c757b7">BAND</a> macro.</li></ul>
<p>
<ul>
<li><a class="el" href="group__app.html#gfb4e3c89d60cf32cc974d72af22f5425">IPV6LOWPAN</a> can be 0 or 1. This flag, if set to one, causes 6LoWPAN to be compiled in, which causes RUM to use compressed IPV6 frame in accordance with RFC4944. This allows nodes to be addressed worldwide by a world-unique IPV6 internet address. If IPV6LOWPAN is zero, then no 6LoWPAN or IPv6 code will be compiled in. Disabling IPV6 saves some space if it will not be used.</li></ul>
<p>
<ul>
<li><a class="el" href="group__app.html#gd72dbcf6d0153db1b8d8a58001feed83">DEBUG</a> can be 1 or 0. This enables/disables diagnostic messages from the serial port. Disabling DEBUG will greatly reduce then object code size (flash size). Note that either <a class="el" href="group__serial.html#gae3f0b4211ba45d265973d40ccbb5fd1">SERIAL</a> or <a class="el" href="group__mac.html#g5c996598d7430c84fe375519b45dbcdf">OTA_DEBUG</a> must be set to use the DEBUG option.</li></ul>
<p>
<ul>
<li><a class="el" href="group__app.html#gd5c46706b38c7dc7ebb32e964a24fd13">DEMO</a> can be 1 or 0. In DEMO mode, a node picks its parent node as the one with the highest RSSI. Otherwise, a parent is picked by (in sequence) best LQI, lowest number of hops to the coordinator, and then RSSI.</li></ul>
<p>
<ul>
<li><a class="el" href="group__app.html#gc4d049774203601b4c2d477b4f46dbe9">APP</a> can be 0 or 1 (<a class="el" href="group__app.html#g84f1ead330bbcc83a63929c4726080d7">SENSOR</a>). If APP is zero, then no application is linked in other than the default minimal application.</li></ul>
<p>
<ul>
<li><a class="el" href="group__app.html#g7a52419b3bc2a1c7763ace68f3f172fb">RUMSLEEP</a> can be 0 or 1. This enables/disables the sleep code. In the sensor application, an end node will go to sleep between readings if RUMSLEEP is set to one. This sleep code is general-purpose and can be used by new applications also. On coordinator and router nodes, this option makes a parent node store a frame destined for a sleeping child node, and will send the frame to the child immediately after it has woken up. See also the <a class="el" href="group__mac.html#g129500a5752ba8bc8abba3844efe45f6">VLP</a> flag.</li></ul>
<p>
<ul>
<li><a class="el" href="group__mac__associate.html#g339b747fe4e5bb7e7f252ba56727e3f5">PAN_CHANNEL</a> sets a fixed channel for the node. If PAN_CHANNEL is not set, then the node will scan all channels. This applies to coordinators, routers, and end nodes. Setting PAN_CHANNEL on a coordinator fixes the network to that channel. Setting PAN_CHANNEL on a router or end node means that the node will only scan one channel, and cannot find any network operating on any other channel.</li></ul>
<p>
<ul>
<li><a class="el" href="group__mac__associate.html#g30931c9744e3a05a13e7c0f36ef20255">PAN_ID</a> sets the PAN ID for the node. Only the coordinator uses this definition. If PAN_ID is not set, then the coordinator chooses a random PAN ID. The routers and end nodes get the PAN ID from the coordinator.</li></ul>
<p>
<ul>
<li><a class="el" href="group__sleep.html#g14ae199e1518c5cdc08368fd78d6a437">WDOG_SLEEP</a> sets the timing source for sleeping to be the on-board AVR watchdog timer. If WDOG_SLEEP is set to zero, then the low-power oscillator should be connected to a 32.768KHz crystal.</li></ul>
<p>
After compiling, you can load the code using a tool like avarice or avrdude. Debugging is possible under linux using avarice and a JTAGICE MK-II, or one of many other programmers that are available. In some AVR chips, only debugWire is supported.<h2><a class="anchor" name="other_flags">
Other compilation options</a></h2>
There are a few other compilation options that are not global. These may be defined in the AVR Studio project settings, or on the avr-gcc command line. They may also be changed in the source code to permanently set the option.<p>
<ul>
<li><a class="el" href="group__sensors.html#g56d52d2738e5c93e3360a339438082cf">SENSOR_TYPE</a> configures which type of sensor to read. If SENSOR_TYPE is not set, the node defaults to sending random data. This option is set in <a class="el" href="sensors_8c-source.html">sensors.c</a>, where the valid sensor types are listed.</li></ul>
<p>
<ul>
<li><a class="el" href="group__mac.html#g036a88551664cfe893bc3f51a64ba179">CHINA_MODE</a> is used to put the radio in IEEE 802.15.4.c mode, which uses special frequencies and modulation modes for use in China. Set CHINA_MODE to "1" to enable this option, or "0" to disable. This option only works with the AT86RF212 radio chip.</li></ul>
<p>
<ul>
<li><a class="el" href="group__radio.html#g14778f0fb49f9a586ceffa5feb1d19b9">DATA_RATE_212</a> sets the data rate and modulation mode to be used with the RF212 (900MHz) chip. Define this setting in <a class="el" href="mac_8h-source.html">mac.h</a>.</li></ul>
<p>
<ul>
<li><a class="el" href="group__sensors.html#g4a713fe1947b9fbecad7a7e84ac721ec">CAL</a> allows the sensor calibration code to be removed from the build. This flag is defined in <a class="el" href="sensors_8c-source.html">sensors.c</a>, and cannot be specified from the command line. If set to one, then the calibration code is compiled in.</li></ul>
<p>
<ul>
<li><a class="el" href="group__mac.html#g129500a5752ba8bc8abba3844efe45f6">VLP</a> puts the node into Very Low Power mode. This is meant for nodes with limited power capacity - for example, an energy-harvesting node, or a node running on low-current batteries. In this mode, the node cannot stay awake for more than a few hundred milliseconds, and cannot be woken up indefinitely. This option is off by default.</li></ul>
<p>
<ul>
<li><a class="el" href="group__serial.html#gae3f0b4211ba45d265973d40ccbb5fd1">SERIAL</a> brings in the serial code. If you are compiling with <a class="el" href="group__app.html#gd72dbcf6d0153db1b8d8a58001feed83">DEBUG</a> on, then you need either SERIAL or OTA_DEBUG set.</li></ul>
<p>
<ul>
<li><a class="el" href="group__mac.html#g5c996598d7430c84fe375519b45dbcdf">OTA_DEBUG</a> allows sending debug messages over the air, to be displayed by the coordinator. This option is useful for getting debug information from nodes that do not have a serial port.</li></ul>
<h2><a class="anchor" name="troubleshooting">
Troubleshooting RUM</a></h2>
There are a several steps to bringing up RUM on a new platform (or even a new board of an existing platform). This section guides you through the steps to verify functionality of the platform.<p>
<b>NOTE:</b> These instructions apply to the AVR-based platforms. There may be slight differences for troubleshooting other platforms, although the goal of each step is the same.<p>
<ol type=1>
<li>Verify that the radio is communicating with the microcontroller. On startup, the microcontroller intializes the radio chip using the SPI port. Part of that initialization involves setting a radio register and then waiting for that register setting to be read back correctly. If the commuication is not working, then the code will hang at this point. The simplest way to verify that the radio is properly communicating is to set a breakpoint on the <a class="el" href="group__mac__event.html#g9b4bd3c99bd01a997dfbf36de2db14ae" title="This is the main loop task for the MAC.">macTask()</a> function, and run the program. If the breakpoint is reached, then the radio is properly communicating over the SPI port.</li><li>Verify that the system timer is running. Set a breakpoint on the Interrupt Service Routine, which is in <a class="el" href="avr__timer_8c-source.html">avr_timer.c</a> If this breakpoint is hit, then the system timer is working.</li><li>Verify that the radio is able to generate system interrupts. Set a breakpoint on the radio ISR in <a class="el" href="hal__avr_8c-source.html">hal_avr.c</a> (look for "ISR(RADIO_VECT)"). If this breakpoint is reached, then the radio is generating interrupt signals, and the microcontroller is servicing them. The radio should generate interrupts on startup, because the radio sends beacon request packets as part of a scan, and the radio generates an interrupt each time it sends a packet.</li><li>Verify that the radio is receiving packets. You can trace the parsing of an incoming packet by putting breakpoints inside the following functions:<ul>
<li><a class="el" href="group__radio.html#ge03d5aceb33d29231cf12d1d3e0997ae" title="Callback function, called when the radio has received a TRX_END interrupt.">radioTrxEndEvent()</a> - put a breakpoint on the line "hal_frame_read();"</li><li><a class="el" href="group__mac__event.html#g9b4bd3c99bd01a997dfbf36de2db14ae" title="This is the main loop task for the MAC.">macTask()</a> - look at cases MAC_EVENT_SCAN and MAC_EVENT_RX.</li><li><a class="el" href="group__mac__data.html#gd3e85e09f6dbb0b41c432986a4a17fec" title="This function is called when the MAC receives a packet that is addressed to this...">macDataIndication()</a> - trace through this function so see that the packet is properly dispatched. </li></ul>
</li></ol>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Mon Jun 8 18:38:19 2009 for RUM by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
