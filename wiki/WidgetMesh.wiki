#summary WidgetMesh - Mesh Network Protocol for Widgets
----
<wiki:toc max_depth="3" />
----
=Widget Mesh=
==Goal==
The goal of this sub project is to provide simple mesh networking for the widgets.  Something along the lines of a cutdown [http://en.wikipedia.org/wiki/Zigbee Zigbee]/SP100a/[http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4578&family_id=676 RUM] stack.

Some of the features I'd ultimately like to implement:
 * Frequency hopping to give diversity to interference.
 * TDMA type access to media. Allow contention free access to RF for all nodes in the network.
 * Basic Meshing, extending the range of sensor, routing of packets over alternate routes if nodes fail etc
 * Remote firmware updates.

== Network Overview ==
the network consists of the following:
 #) Gateway Device - At least one gateway device is required to form the network, the role of this is to co-ordinate the forming of the network and and the routing of packets to and from the WidgetMesh network, i.e. sends data through to a connected device for data-management e.g. a connected PC or a network.
 #) Network Nodes - The rest of the network consists of widgets, these may be low powered battery or connected to mains.  The nodes when configured will search for and join the network under the coordination of the gateway device.

=== Frequency Hopping===
To provide resistance to RF interference, the mesh should provide the ability for the nodes to communicate over a number of different frequencies.  These frequencies are switched on a regular basis in a set pattern, so all nodes on the network know what channel to communicate on.

Each node on the network has a default channel hopping pattern in the firmware, additional channel patterns can be assigned by the gateway device.

The Frequency of the channel is based on a lookup table and is different each time. 

=== TDMA Slotted Access ===
[http://en.wikipedia.org/wiki/Time_division_multiple_access Time Division Multiple Access (TDMA)] provides a shared slotted access to the RF media.  

This consists of a repeating superframe made up of individual time slots of set length. e.g. 10mSec slots and superframe of 1 Second = 100 slots.

This length of the time slot must allow for a single packet to be sent with a response acknowledgement packet.

Each timeslot consists of a number of communication cells, these cells can be assigned non overlapping frequencies so are without RF collisions at any timeslot. e.g. a 16 cell timeslot can be assigned 16 different devices that will not interfere with each other.

The frequency/channel for each cell will hop and is not fixed.  i.e. The cell is not the absolute channel but an offset derived from a frequency table and will change at each timeslot.  The offset effectively shifts the hopping pattern to the left by the value of the offset. 

e.g. with a hopping pattern of 2,8,13,5,10,14,4,11,7,12,1,6,15,9,0 and offset of 2 gives a hopping pattern of 13,5,10,14,4,11,7,12,1,6,15,9,0,2,8

Cells can be assigned link functions such as unicast cells (A --> B), Broadcast Cells (Q --> `*`) or Shared Access Cells (`*` --> `*`).  During a timeslot that is not assigned to an individual node then the node can have the Rx circuit turned off to save power.   Cell function assignment is performed by the gateway device during association requests or network reconfiguration (i.e. dis-association or lost nodes).

To use this slotted access scheme, a notion of network time needs to be available across the network, this should be synchronised either from the Gateway or Coordinator node or a time source.

The diagram below (based on SP100A) shows a portion (250mSec) of a Super-frame and how the frequency hopping is integrated into TDMA as seen from a single device on the network.  Other nodes will have Cell offsets assigned to them and is overlaid on this diagram.   Link Assignments between nodes in the network are shown as dedicated links i.e. can only Send or Receive between node a and node b, additional nodes will be assigned their own cells.  Shared Links are used as advertisement or broadcast slots by all nodes assigned.

http://strobit.googlecode.com/svn/wiki/images/widgetmesh/SuperFrame.png

The diagram below shows offsets of the same hopping sequence interleaved with the original hopping pattern.  The numbers in the cells represent the offset applied to the hopping pattern.  This offset allows different devices to work in the same physical area with no RF interference.

http://strobit.googlecode.com/svn/wiki/images/widgetmesh/SuperFrame1.png

=== Self Forming and Self Healing ===

If the minimum network requirement are met then the network should be self forming.  A node when first powered up will listen for other node communications in its vicinity and allowing it to sent join requests to form network links ([WidgetMeshAssociation]).  The network will form from the gateway out.

The network should be self healing, if a node fails or for some reasons is disconnected from the network, then the rest of the network should be able to re-form as best as possible.

http://strobit.googlecode.com/svn/wiki/images/widgetmesh/mesh_overview.png

----

==stack Overview==
http://strobit.googlecode.com/svn/wiki/images/widgetmesh/stacksml.png

----

==Design==

===Physical Layer===
The Physical Layer is provided by the RFM12 Driver.

The driver will provide functions to:
 * Change frequency
 * Change Tx Power
 * Report RSSI (Optional)
 * Put RF into Low Power/Sleep Mode
 * Tx Data
 * Rx Data

===MAC Layer ===
The purpose of the MAC layer is to add the required preamble and SYNC bytes to the data packets being transmitted.

Pre-amble Bytes:  Required by the RFM12B transceiver for FSK lock, always 0xAA.  

Sync Bytes:  The sync bytes are required by the RFM12B transceiver, the first is fixed and cannot be changed, the second byte is used to represent network ID.

http://strobit.googlecode.com/svn/wiki/images/widgetmesh/mpdu.png

|| 0xAA || 0xAA || 0x2D || 0xD4 || DPDU (2 - n bytes) || 0xAA||

0xD4 is the network ID

TODO: May want to handle error detection at this level so extra work is not performed by the upper layers if a corrupt packet, i.e. drop the packet here if corrupt.  To handle CRC then an extra 3 bytes are required. DPDU payload byte count and CRC16 bytes.

TODO: May also want to implement Forward Error correction using Manchester Encoding in this layer.  Will halve data rate if implemented.

TODO: Encryption.  Implement payload encryption using [http://www.efton.sk/crypt/index.htm XTEA], RC4?, AES?, Skipjack?  resources required?  Data throughput?

===Data Link Layer===

The majority of network functions are handled by this layer.
   * [WidgetMeshAssociation Network Discovery and Association]
   * [WidgetMeshRouting Network Routing]

----

==Implementation==
WidgetMesh is implemented on the [http://www.sics.se/contiki/ ContikiOS] and is available via the [http://code.google.com/p/strobit/source/browse/#svn/trunk/widgetmesh project SVN].

Current Status: 
  * ContikiOS ported to RFM12Widget Platform
  * Hello-world example successfully running.
  * no networking.